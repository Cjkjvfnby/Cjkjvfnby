# Import or from import that is a question

Есть три стадии знаний: ты используешь инструмент, 
ты понимаешь как он работает, ты можешь учить других работать этим инструментом.
Потихонечку начал перетекать в третью и стал задавать себе вопросы, которые раньше не задавал.

Например, что лучше: `import module` или `from module import function`?

Я решил разобраться в этом чуть поглубже, ответы на Stack Overflow меня не удовлетворили.

Для тех, кому лень читать: все варианты хороши.

# Советы от создателей языка 
Обратимся к первоисточникам, а именно [PEP8](https://www.python.org/dev/peps/pep-0008/#imports)

Когда импортируете класс из модуля, будет нормально сделать это так:
```python
from myclass import MyClass
from foo.bar.yourclass import YourClass
```

Если это вызывает локальный конфликт имён, то можно сделать это явно:
```python
import myclass
import foo.bar.yourclass
```
И использовать как `myclass.MyClass` и `foo.bar.yourclass.YourClass`

PEP-8 это не законы, это рекомендации и в данном случае нам советуют выбирать лучшее для своего случая.

# Кто принимает решение?

Решение, как импортировать модуль, в первую очередь принимает тот, кто пишет код модуля.
В большинстве случаев об этом не задумываются, и получается что получается. 
В основном модули совместимы с обоими подходами. 

## Первый способ показать, как правильно использовать библиотеку, идет через документацию

Не ту документацию, которую никто не читает, а примеры использования. 

"Фляжка" и "бутылка" идут по пути точечных импортов.
```python
from flask import Flask
app = Flask(__name__)

@app.route('/')
def hello_world():
    return 'Hello, World!
```

```python
from bottle import route, run, template

@route('/hello/<name>')
def index(name):
    return template('<b>Hello {{name}}</b>!', name=name)

run(host='localhost', port=8080)
```

Пайтест выбирает импортирование модуля.
```python
import pytest


def test_zero_division():
    with pytest.raises(ZeroDivisionError):
        1 / 0
```
В случае пайтеста это вполне логичный выбор, так как эта библиотека должна быть максимально совместима со всем кодом на планете.
У неё один из самых высоких шансов получить локальный конфликт имён.
Даже есть [плагин](https://github.com/m-burst/flake8-pytest-style/blob/v1.3.0/docs/rules/PT013.md)
для линтера который проверяет что импорты оформлены как надо.

## Второй подход, менее явный, это выбор имен внутри модуля

```python
from json import load, save
```
Если имена без модуля теряют контекст, 
то автор как бы намекает, что импортировать надо через модуль.  

Обратный случай – когда имена модуля и его содержимого очень большие и загромождают код.

Короткие, абстрактные имена – это прерогатива создателей стандартной библиотеки языка.
Для своего же кода я выбираю имена среднего и большого размера, которые понятны без контекста в виде имени модуля.

Но граничные случаи редки, и большинство библиотек не вызывают проблем при использовании любого из подходов.

## Секция импортов
Импорты я добавляю через автоподсказки ИДЕ. 
По умолчанию они свёрнуты, при ревью я их бегло пролистываю.
Инструменты сами расставляют их в нужном порядке и делают проверки.

Случай, когда мне нужно из модуля импортировать десятки сущностей, меня не смущает в контексте данного исследования.

## Простота чтения 
При импорте отдельных объектов получатся более короткий код. Его проще читать. Меньше переносов строк.
В целом чуда не случается, но читать приятнее.

## Рефакторинг
В ИДЕ поддерживаются оба случая на одном уровне, и автоматика работает одинаково. 
Но иногда бывают сбои: мерджи с другим кодом, ручные переименования, перенесение файлов по модулям.
Если переименовали объект, а использования забыли, то в одном случае код упадёт сразу,
а при доступе к атрибутам – только в момент вызова.

Если у вас 100% покрытие тестами – разницы нет. Если нет, то второй случай пропустить легко.

## MonkeyPatch 
При написании тестов порой надо подменить какие-то методы. 
Вот тут c точечными импортами начинается цирк. 
К моменту, когда накладывается патч, ссылка на объект уже имеется в тех местах, где он импортирован,
и патчить нужно не место, где объект объявлен, а все места, где был сделан импорт.
Не сложно, но немного запарно, и есть шанс что-то поломать при рефакторинге.

Этот момент – достаточно частый источник недоумения. 

## Производительность и память
Бытует миф, что если импортировать из модуля только одну функцию, то будет экономия памяти.
В обоих случаях весь модуль импортируется в память, разницы в производительности нет.

## Пространство имён
Если в пространстве имён есть конфликты, то Питон позволяет их обойти двумя способами.
Либо `import module`, либо `from module import item as module_item`. 
Мне подход с модулем больше нравится as практически не использую.

# Единообразие
На мой взгляд, использование обоих подходов не сильно нарушает единообразие, и можно их спокойно смешивать.
Желательно, правда, не для одного и того же модуля.

# Заключение
Для себя я выбираю следующий подход при импортировании и написании своих модулей. 
Использовать `import from`, кроме случаев:
 - есть конфликт имён
 - использую библиотеки с короткими именами внутри (json)
 - использую pytest.  
