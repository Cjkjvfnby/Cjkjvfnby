# `import` or `from import`, that is a question

Есть три стадии знаний: ты используешь инструмент, 
ты понимаешь как он работает, ты можешь учить других работать этим инструментом.
Потихонечку начал перетекать в третью и стал задавать себе вопросы, которые раньше не задавал.

Например, что лучше: `import module` или `from module import function`?

Я решил разобраться в этом чуть поглубже, ответы на Stack Overflow меня не удовлетворили.

Для тех, кому лень читать: все варианты хороши.

# Советы от создателей языка 
Обратимся к первоисточникам, а именно — к [PEP8](https://www.python.org/dev/peps/pep-0008/#imports)

Когда импортируете класс из модуля, будет нормально сделать это так:
```python
from myclass import MyClass
from foo.bar.yourclass import YourClass
```

Если это вызывает локальный конфликт имён, то можно сделать это явно:
```python
import myclass
import foo.bar.yourclass
```
И использовать как `myclass.MyClass` и `foo.bar.yourclass.YourClass`

PEP-8 это не законы, это рекомендации и в данном случае нам советуют выбирать лучшее для своего случая.

# Кто принимает решение?

Решение, как импортировать модуль, в первую очередь принимает тот, кто пишет код модуля.
В большинстве случаев об этом не задумываются, и получается что получается. 
В основном модули совместимы с обоими подходами. 

## Документация

Самый очевидный способ продемонстрировать, как пользоваться библиотекой, — документация.
Не ту документацию, которую никто не читает, а примеры использования. 

"Фляжка" и "бутылка" идут по пути точечных импортов.
```python
from flask import Flask
app = Flask(__name__)

@app.route('/')
def hello_world():
    return 'Hello, World!
```

```python
from bottle import route, run, template

@route('/hello/<name>')
def index(name):
    return template('<b>Hello {{name}}</b>!', name=name)

run(host='localhost', port=8080)
```

Пайтест выбирает импортирование модуля.
```python
import pytest


def test_zero_division():
    with pytest.raises(ZeroDivisionError):
        1 / 0
```
В случае пайтеста это вполне логичный выбор, так как эта библиотека должна быть максимально совместима со всем кодом на планете.
У неё один из самых высоких шансов получить локальный конфликт имён.
Даже есть [плагин](https://github.com/m-burst/flake8-pytest-style/blob/v1.3.0/docs/rules/PT013.md)
для линтера который проверяет, что импорты оформлены правильно.

## Имена атрибутов модуля

Второй подход, менее явный, это выбор имен внутри модуля.
```python
import json

json.load
json.loads
json.dump
json.dumps
```

Если имена без модуля теряют контекст, 
то автор как бы намекает, что импортировать надо через модуль.
```python
from pickle import load
from marshal import dumps
from xmlrpc.client import loads
from xml.etree.ElementTree import dump
```
Например, `json.load` безопасная функция, в то время как `pickle.load` возможная дыра в безопасности — контекст здесь имеет важную роль.
  

Обратный случай – когда имена модуля и его содержимого очень большие и загромождают код.

Короткие, абстрактные имена – это прерогатива создателей стандартной библиотеки языка.
Для своего же кода я выбираю имена среднего и большого размера, которые понятны без контекста в виде имени модуля.

Но граничные случаи редки, и большинство библиотек не вызывают проблем при использовании любого из подходов.

## Секция импортов
Импорты я добавляю через автоподсказки ИДЕ. 
По умолчанию они свёрнуты, при ревью я их бегло пролистываю.
Инструменты сами расставляют их в нужном порядке и делают проверки.

Случай, когда мне нужно из модуля импортировать десятки сущностей, меня не смущает в контексте данного исследования.

## Простота чтения 
При импорте отдельных объектов получатся более короткий код. Его проще читать. Меньше переносов строк.
В целом чуда не случается, но читать приятнее.

## Рефакторинг
В ИДЕ поддерживаются оба случая на одном уровне, и автоматика работает одинаково. 
Но иногда бывают сбои: мерджи с другим кодом, ручные переименования, перенесение файлов по модулям.
Если переименовали объект, а использования забыли, то в одном случае код упадёт сразу,
а при доступе к атрибутам – только в момент вызова.

Если у вас 100% покрытие тестами – разницы нет. Если нет, то второй случай пропустить легко.

## MonkeyPatch 
При написании тестов порой надо подменить какие-то методы. 
Вот тут c точечными импортами начинается цирк. 
К моменту, когда накладывается патч, ссылка на объект уже имеется в тех местах, где он импортирован,
и патчить нужно не место, где объект объявлен, а все места, где был сделан импорт.
Несложно, но немного запарно, и есть шанс что-то поломать при рефакторинге.

Этот момент – достаточно частый источник недоумения. 

## Производительность и память
Бытует миф, что импортирование из модуля только части классов/функций экономит память.
На деле в обоих случаях в память загружается модуль целиком, и разницы в производительности нет.

## Пространство имён
Если в пространстве имён есть конфликты, то Питон позволяет их обойти двумя способами.
Либо `import module`, либо `from module import item as module_item`. 
Мне подход с модулем больше нравится, `as` практически не использую, 
пусть лучше будет чуть больше кода с известными сущностями, чем добавление новых. Хотя есть и устоявшиеся традиции.
```python
import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
```

# Единообразие
На мой взгляд, использование обоих подходов не сильно нарушает единообразие, и можно их спокойно смешивать.
Желательно, правда, не для одного и того же модуля.

# Заключение
Для себя я выбираю следующий подход при импортировании и написании своих модулей. 
Использовать `import from`, кроме случаев:
 - есть (или вероятен впоследствии) конфликт имён;
 - функции/классы модуля имеют короткие и распространённые имена (`json`);
 - существуют устоявшиеся традиции или конкретные рекомендации авторов модуля;
 - `import pytest`.
